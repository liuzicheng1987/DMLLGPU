struct SumDeltaActivation1 {

  Activation activation;
  NeuralNetworkNodeGPUCpp **HiddenNodesIAmFedIntoPtr;
  std::int32_t *NumWeightIAmToNodeIAmFedInto;
  

  SumDeltaActivation1(Activation _activation, NeuralNetworkNodeGPUCpp **_HiddenNodesIAmFedIntoPtr, std::int32_t *_NumWeightIAmToNodeIAmFedInto) : activation(_activation), HiddenNodesIAmFedIntoPtr(_HiddenNodesIAmFedIntoPtr), NumWeightIAmToNodeIAmFedInto(_NumWeightIAmToNodeIAmFedInto) {}
  
  __device__
  float operator()(std::int32_t &i) const {

      switch(this->activation) {

      case linear:
	return this->HiddenNodesIAmFedIntoPtr[0]->calc_dLdInput(this->NumWeightIAmToNodeIAmFedInto[0], i);

      default:
	return 0.0f;
      }
    }

};

void SumDeltaActivation(std::vector<NeuralNetworkNodeGPUCpp*> &HiddenNodesIAmFedIntoPtr, std::int32_t *NumWeightIAmToNodeIAmFedInto, thrust::device_vector<float> &delta, Activation activation) {
  
  thrust::counting_iterator<std::int32_t> CounterBegin(0);
  thrust::counting_iterator<std::int32_t> CounterEnd = CounterBegin + delta.size();

  switch(HiddenNodesIAmFedIntoPtr.size()) {
   
  case 0:
    throw std::invalid_argument("Hidden node is not fed into any other node!");
    
  case 1:
    thrust::transform(CounterBegin, CounterEnd, delta.begin(), SumDeltaActivation1(activation, HiddenNodesIAmFedIntoPtr.data(), NumWeightIAmToNodeIAmFedInto));
     break;

  }
};


